<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>视频转序列帧 - jiangking</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', sans-serif;
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            min-height: 100vh;
            color: #333;
            font-size: 14px;
        }

        /* Header */
        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 20px 0;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            position: sticky;
            top: 0;
            z-index: 100;
        }

        .header-content {
            max-width: 1200px;
            margin: 0 auto;
            padding: 0 20px;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .logo-section {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .logo {
            font-size: 28px;
            font-weight: 800;
            color: white;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.2);
            letter-spacing: -1px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .logo-icon {
            width: 36px;
            height: 36px;
            background: white;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .nav-section {
            display: flex;
            align-items: center;
            gap: 20px;
        }

        .nav-link {
            display: flex;
            align-items: center;
            gap: 8px;
            background: rgba(255,255,255,0.2);
            color: white;
            text-decoration: none;
            padding: 10px 20px;
            border-radius: 50px;
            font-size: 15px;
            font-weight: 500;
            transition: all 0.3s;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.3);
        }

        .nav-link:hover {
            background: rgba(255,255,255,0.3);
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }

        .nav-icon {
            font-size: 18px;
        }

        /* Main Container */
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        .subtitle {
            text-align: center;
            color: #5a67d8;
            margin: 0 auto 30px;
            font-size: 18px;
            font-weight: 500;
            background: white;
            padding: 15px 30px;
            border-radius: 50px;
            display: inline-block;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            max-width: 90%;
        }

        /* Content Layout */
        .content-wrapper {
            background: white;
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.8);
        }

        /* Upload Section */
        .upload-section {
            margin-bottom: 20px;
        }

        .upload-title {
            font-size: 14px;
            color: #666;
            margin-bottom: 10px;
        }

        .main-content {
            display: grid;
            grid-template-columns: 300px 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }

        .upload-area {
            border: 3px dashed #cbd5e0;
            border-radius: 16px;
            padding: 40px 20px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
            background: linear-gradient(135deg, #f8fafc 0%, #f0f4f8 100%);
            position: relative;
            overflow: hidden;
        }

        .upload-area::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: radial-gradient(circle, rgba(102, 126, 234, 0.1) 0%, transparent 70%);
            animation: pulse 3s ease-in-out infinite;
            pointer-events: none;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(0.8); opacity: 0.5; }
            50% { transform: scale(1.2); opacity: 0.8; }
        }

        .upload-area:hover {
            border-color: #667eea;
            background: linear-gradient(135deg, #f0f4f8 0%, #e9ecef 100%);
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(102, 126, 234, 0.2);
        }

        .upload-icon {
            font-size: 64px;
            color: #667eea;
            margin-bottom: 15px;
            animation: float 3s ease-in-out infinite;
        }

        @keyframes float {
            0%, 100% { 
                transform: translateY(0px) rotate(-5deg); 
            }
            50% { 
                transform: translateY(-15px) rotate(5deg); 
            }
        }

        .upload-text {
            color: #4a5568;
            margin-bottom: 10px;
            font-size: 18px;
            font-weight: 500;
        }

        .upload-btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 12px 32px;
            border-radius: 50px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 600;
            transition: all 0.3s;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
            position: relative;
            overflow: hidden;
        }

        .upload-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.3), transparent);
            transition: left 0.5s;
        }

        .upload-btn:hover::before {
            left: 100%;
        }

        .upload-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.5);
        }

        .file-input {
            display: none;
        }

        /* Video Preview */
        .video-preview {
            background: #000;
            border-radius: 16px;
            overflow: hidden;
            position: relative;
            aspect-ratio: 16/9;
            box-shadow: 0 8px 24px rgba(0,0,0,0.15);
            display: none;
        }

        .video-preview video {
            width: 100%;
            height: 100%;
            object-fit: contain;
        }

        .video-controls {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: rgba(0,0,0,0.7);
            padding: 10px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .play-btn {
            background: none;
            border: none;
            color: white;
            font-size: 20px;
            cursor: pointer;
            padding: 5px;
        }

        .time-display {
            color: white;
            font-size: 12px;
            margin-left: auto;
        }

        /* File Info */
        .file-info {
            display: none;
            align-items: center;
            gap: 10px;
            margin-bottom: 20px;
            color: #666;
            font-size: 12px;
        }

        .reset-btn {
            margin-left: auto;
            background: white;
            border: 2px solid #e2e8f0;
            padding: 8px 16px;
            border-radius: 50px;
            cursor: pointer;
            font-size: 13px;
            font-weight: 500;
            transition: all 0.3s;
            color: #718096;
        }

        .reset-btn:hover {
            border-color: #cbd5e0;
            background: #f7fafc;
            transform: translateY(-1px);
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
        }

        /* Segment Selection */
        .segment-section {
            background: linear-gradient(135deg, #e0e7ff 0%, #cfd9f9 100%);
            border: 2px solid #c7d2fe;
            border-radius: 16px;
            padding: 25px;
            margin-bottom: 20px;
            box-shadow: 0 4px 10px rgba(102, 126, 234, 0.1);
            display: none;
        }

        .segment-header {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 15px;
        }

        .segment-title {
            font-size: 14px;
            color: #333;
        }

        .segment-preview {
            background: white;
            border: 2px solid #e2e8f0;
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 15px;
            min-height: 100px;
            position: relative;
            box-shadow: 0 2px 8px rgba(0,0,0,0.05);
        }

        .preview-video {
            width: 100%;
            height: 200px;
            background: #000;
            border-radius: 12px;
            position: relative;
            overflow: hidden;
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.1);
        }

        .preview-video video {
            width: 100%;
            height: 100%;
            object-fit: contain;
        }

        .preview-controls {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: rgba(0,0,0,0.7);
            padding: 5px 10px;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .segment-info {
            font-size: 12px;
            color: #666;
            margin: 10px 0;
        }

        .segment-info a {
            color: #4285f4;
            text-decoration: none;
        }

        /* Timeline Slider */
        .timeline-container {
            margin: 20px 0;
            padding: 20px;
            background: white;
            border-radius: 16px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.05);
        }

        .timeline-label {
            font-size: 14px;
            color: #333;
            margin-bottom: 15px;
            display: flex;
            justify-content: space-between;
            font-weight: 500;
        }

        .timeline-wrapper {
            position: relative;
            margin-bottom: 20px;
            padding: 0 15px; /* Add padding to ensure handles are visible */
        }

        .timeline-slider {
            position: relative;
            height: 80px;
            background: #f0f4f8;
            border-radius: 12px;
            margin: 10px 0;
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.06);
            overflow: visible;
            cursor: pointer;
            user-select: none;
            -webkit-user-select: none;
        }

        .timeline-slider.dragging {
            cursor: grabbing !important;
        }

        .timeline-slider.dragging .timeline-selection,
        .timeline-slider.dragging .timeline-handle {
            transition: none !important;
        }

        .timeline-waveform {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            opacity: 0.3;
            pointer-events: none;
        }

        .timeline-progress {
            position: absolute;
            top: 0;
            left: 0;
            height: 100%;
            width: 0;
            background: rgba(102, 126, 234, 0.1);
            pointer-events: none;
        }

        .timeline-selection {
            position: absolute;
            top: 0;
            height: 100%;
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.3) 0%, rgba(118, 75, 162, 0.3) 100%);
            border: 2px solid #667eea;
            border-radius: 8px;
            transition: background 0.2s;
            cursor: move;
            box-sizing: border-box;
            z-index: 2;
        }

        .timeline-selection:hover {
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.4) 0%, rgba(118, 75, 162, 0.4) 100%);
        }

        .timeline-selection.dragging {
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.5) 0%, rgba(118, 75, 162, 0.5) 100%);
            border-color: #5a67d8;
            box-shadow: 0 0 0 4px rgba(102, 126, 234, 0.2);
            cursor: grabbing !important;
        }

        .timeline-selection::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 40px;
            height: 4px;
            background: #667eea;
            border-radius: 2px;
            opacity: 0.5;
        }

        .timeline-handle {
            position: absolute;
            top: 50%;
            width: 16px;
            height: 48px;
            background: white;
            border: 3px solid #667eea;
            border-radius: 8px;
            transform: translateY(-50%);
            cursor: ew-resize;
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
            transition: transform 0.2s, box-shadow 0.2s, background 0.2s;
            z-index: 15;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .timeline-handle:hover {
            background: #667eea;
            transform: translateY(-50%) scale(1.1);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
        }

        .timeline-handle:active,
        .timeline-handle.dragging {
            transform: translateY(-50%) scale(1.05);
            background: #5a67d8;
            border-color: #5a67d8;
        }

        .timeline-handle.start {
            border-top-right-radius: 4px;
            border-bottom-right-radius: 4px;
        }

        .timeline-handle.end {
            border-top-left-radius: 4px;
            border-bottom-left-radius: 4px;
        }

        .timeline-handle::after {
            content: '';
            width: 2px;
            height: 24px;
            background: currentColor;
            border-radius: 1px;
            opacity: 0.8;
        }

        .timeline-time-tooltip {
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.9);
            color: white;
            padding: 6px 10px;
            border-radius: 6px;
            font-size: 12px;
            font-weight: 500;
            white-space: nowrap;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s;
            margin-bottom: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
        }

        .timeline-time-tooltip::after {
            content: '';
            position: absolute;
            top: 100%;
            left: 50%;
            transform: translateX(-50%);
            width: 0;
            height: 0;
            border-left: 6px solid transparent;
            border-right: 6px solid transparent;
            border-top: 6px solid rgba(0,0,0,0.9);
        }

        .timeline-handle:hover .timeline-time-tooltip,
        .timeline-selection.dragging .timeline-time-tooltip,
        .timeline-handle.dragging .timeline-time-tooltip {
            opacity: 1;
        }

        .timeline-ruler {
            position: absolute;
            bottom: -20px;
            left: 0;
            right: 0;
            height: 20px;
            display: flex;
            justify-content: space-between;
            padding: 0 5px;
            user-select: none;
        }

        .timeline-ruler-mark {
            position: relative;
            width: 1px;
            height: 10px;
            background: #ddd;
        }

        .timeline-ruler-mark::after {
            content: attr(data-time);
            position: absolute;
            top: 12px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 10px;
            color: #999;
            white-space: nowrap;
        }

        .timeline-info {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 15px;
            margin-top: 15px;
        }

        .timeline-info-item {
            text-align: center;
            padding: 10px;
            background: #f8f9fa;
            border-radius: 8px;
            transition: all 0.3s;
        }

        .timeline-info-item:hover {
            background: #e9ecef;
            transform: translateY(-1px);
        }

        .timeline-info-label {
            font-size: 11px;
            color: #666;
            margin-bottom: 4px;
        }

        .timeline-info-value {
            font-size: 16px;
            font-weight: bold;
            color: #667eea;
        }

        .timeline-preview-line {
            position: absolute;
            top: 0;
            width: 2px;
            height: 100%;
            background: #ff4444;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s;
            z-index: 5;
        }

        .timeline-preview-line.active {
            opacity: 1;
        }

        .preview-time-tooltip {
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 68, 68, 0.9);
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 11px;
            font-weight: 500;
            white-space: nowrap;
            margin-bottom: 4px;
            opacity: 0;
            transition: opacity 0.2s;
            pointer-events: none;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }

        /* Quick Select */
        .quick-select {
            display: flex;
            align-items: center;
            gap: 10px;
            margin: 15px 0;
        }

        .quick-select-label {
            font-size: 12px;
            color: #666;
        }

        .time-btn {
            background: white;
            border: 2px solid #e2e8f0;
            padding: 8px 16px;
            border-radius: 50px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.3s;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
        }

        .time-btn:hover {
            border-color: #667eea;
            color: #667eea;
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }

        .time-btn.active {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-color: transparent;
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3);
        }

        /* Video Stats */
        .stats-grid {
            display: none;
            grid-template-columns: repeat(4, 1fr);
            gap: 20px;
            margin: 20px 0;
            padding: 25px;
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            border-radius: 16px;
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.06);
        }

        .stat-item {
            text-align: center;
            padding: 15px;
            background: white;
            border-radius: 12px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.08);
            transition: all 0.3s;
        }

        .stat-item:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.12);
        }

        .stat-label {
            font-size: 12px;
            color: #666;
            margin-bottom: 5px;
        }

        .stat-value {
            font-size: 20px;
            font-weight: bold;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-top: 5px;
        }

        .stat-value.small {
            font-size: 14px;
        }

        /* Extract Settings */
        .extract-settings {
            border-top: 1px solid #e0e0e0;
            padding-top: 20px;
            margin-top: 20px;
            display: none;
        }

        .setting-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 20px;
        }

        .setting-label {
            font-size: 14px;
            color: #333;
        }

        .setting-input {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .input-number {
            width: 80px;
            padding: 10px 15px;
            border: 2px solid #e2e8f0;
            border-radius: 50px;
            text-align: center;
            font-size: 16px;
            font-weight: 500;
            transition: all 0.3s;
            background: white;
            color: #667eea;
        }

        .input-number:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 4px rgba(102, 126, 234, 0.1);
        }

        /* Extract Button */
        .extract-btn {
            width: 100%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 16px;
            border-radius: 50px;
            font-size: 18px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
            position: relative;
            overflow: hidden;
        }

        .extract-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.3), transparent);
            transition: left 0.5s;
        }

        .extract-btn:hover::before {
            left: 100%;
        }

        .extract-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.5);
        }

        .extract-btn:disabled {
            background: linear-gradient(135deg, #a0aec0 0%, #718096 100%);
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        /* Frame Selection Page */
        .frame-selection {
            display: none;
        }

        .frame-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .frame-title {
            font-size: 18px;
            color: #333;
        }

        .frame-actions {
            display: flex;
            gap: 10px;
        }

        .action-btn {
            padding: 10px 20px;
            border-radius: 50px;
            border: none;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.3s;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        .action-btn.primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .action-btn.secondary {
            background: white;
            color: #667eea;
            border: 2px solid #667eea;
        }

        .action-btn.success {
            background: linear-gradient(135deg, #48bb78 0%, #38a169 100%);
            color: white;
        }

        .action-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }

        .frames-grid {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 15px;
            margin-bottom: 30px;
        }

        .frame-item {
            position: relative;
            border: 3px solid #e2e8f0;
            border-radius: 12px;
            overflow: hidden;
            cursor: pointer;
            transition: all 0.3s;
            background: white;
            box-shadow: 0 2px 8px rgba(0,0,0,0.08);
        }

        .frame-item:hover {
            transform: translateY(-4px);
            box-shadow: 0 8px 16px rgba(0,0,0,0.12);
        }

        .frame-item.selected {
            border-color: #667eea;
            box-shadow: 0 0 0 4px rgba(102, 126, 234, 0.2);
        }

        .frame-checkbox {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 24px;
            height: 24px;
            cursor: pointer;
            appearance: none;
            -webkit-appearance: none;
            background: white;
            border: 2px solid #e2e8f0;
            border-radius: 6px;
            transition: all 0.3s;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .frame-checkbox:checked {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-color: transparent;
        }

        .frame-checkbox:checked::after {
            content: '✓';
            display: block;
            text-align: center;
            color: white;
            font-size: 16px;
            line-height: 20px;
            font-weight: bold;
        }

        .frame-image {
            width: 100%;
            aspect-ratio: 16/9;
            object-fit: cover;
            display: block;
        }

        .frame-label {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: linear-gradient(to top, rgba(0,0,0,0.8), rgba(0,0,0,0.5));
            color: white;
            text-align: center;
            padding: 8px;
            font-size: 13px;
            font-weight: 500;
            backdrop-filter: blur(10px);
        }

        /* Quick Preview Section */
        .quick-preview {
            background: linear-gradient(135deg, #e0e7ff 0%, #cfd9f9 100%);
            border: 2px solid #c7d2fe;
            border-radius: 16px;
            padding: 25px;
            margin-bottom: 20px;
            box-shadow: 0 4px 10px rgba(102, 126, 234, 0.1);
        }

        .preview-header {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 15px;
        }

        .preview-title {
            font-size: 14px;
            color: #333;
        }

        .preview-main {
            display: flex;
            justify-content: center;
            margin-bottom: 20px;
        }

        .preview-frame {
            width: 200px;
            border: 3px solid #e2e8f0;
            border-radius: 12px;
            overflow: hidden;
            position: relative;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            background: white;
        }

        .preview-frame img {
            width: 100%;
            display: block;
        }

        .frame-number {
            position: absolute;
            bottom: 10px;
            right: 10px;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 12px;
        }

        .preview-slider {
            margin-bottom: 20px;
        }

        .slider-container {
            position: relative;
            padding: 0 10px;
        }

        .slider {
            width: 100%;
            height: 8px;
            -webkit-appearance: none;
            appearance: none;
            background: linear-gradient(to right, #e0e7ff 0%, #cfd9f9 100%);
            border-radius: 4px;
            outline: none;
            box-shadow: inset 0 1px 3px rgba(0,0,0,0.1);
        }

        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 24px;
            height: 24px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 2px 8px rgba(102, 126, 234, 0.4);
            border: 3px solid white;
            transition: all 0.3s;
        }

        .slider::-webkit-slider-thumb:hover {
            transform: scale(1.1);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.6);
        }

        .slider-labels {
            display: flex;
            justify-content: space-between;
            margin-top: 10px;
            font-size: 12px;
            color: #666;
        }



        .control-btn {
            padding: 10px 18px;
            border: 2px solid #e2e8f0;
            border-radius: 50px;
            background: white;
            cursor: pointer;
            font-size: 13px;
            font-weight: 500;
            transition: all 0.3s;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
        }

        .control-btn:hover {
            border-color: #667eea;
            color: #667eea;
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }

        /* Chroma Key Settings */
        .chroma-settings {
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            border-radius: 16px;
            padding: 30px;
            margin-top: 20px;
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.06);
        }

        .settings-title {
            font-size: 16px;
            color: #333;
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .method-selection {
            margin-bottom: 20px;
        }

        .method-label {
            font-size: 14px;
            color: #666;
            margin-bottom: 10px;
        }

        .method-cards {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
        }

        .method-card {
            border: 2px solid #e2e8f0;
            border-radius: 12px;
            padding: 20px;
            cursor: pointer;
            transition: all 0.3s;
            background: white;
            box-shadow: 0 2px 8px rgba(0,0,0,0.05);
        }

        .method-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        }

        .method-card.active {
            border-color: #667eea;
            background: linear-gradient(135deg, #f0f4ff 0%, #e9ecff 100%);
            box-shadow: 0 0 0 4px rgba(102, 126, 234, 0.1);
        }

        .method-card input[type="radio"] {
            margin-right: 10px;
        }

        .method-name {
            font-weight: bold;
            color: #333;
            margin-bottom: 5px;
        }

        .method-desc {
            font-size: 12px;
            color: #666;
        }

        /* Settings Sliders */
        .setting-group {
            margin-bottom: 20px;
        }

        .setting-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .setting-name {
            font-size: 14px;
            color: #333;
        }

        .setting-value {
            font-size: 14px;
            color: #4285f4;
            font-weight: bold;
        }

        .color-selector {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }

        .color-option {
            padding: 10px 20px;
            border: 2px solid #e2e8f0;
            border-radius: 50px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.3s;
            background: white;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
        }

        .color-option:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }

        .color-option.active {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-color: transparent;
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3);
        }

        .tolerance-slider {
            width: 100%;
            margin-bottom: 10px;
            height: 8px;
            -webkit-appearance: none;
            appearance: none;
            background: linear-gradient(to right, #e0e7ff 0%, #cfd9f9 100%);
            border-radius: 4px;
            outline: none;
            box-shadow: inset 0 1px 3px rgba(0,0,0,0.1);
        }

        .tolerance-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 24px;
            height: 24px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 2px 8px rgba(102, 126, 234, 0.4);
            border: 3px solid white;
            transition: all 0.3s;
        }

        .tolerance-slider::-webkit-slider-thumb:hover {
            transform: scale(1.1);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.6);
        }

        .slider-scale {
            display: flex;
            justify-content: space-between;
            font-size: 11px;
            color: #999;
        }

        /* Checkbox Options */
        .checkbox-group {
            margin-bottom: 15px;
        }

        .checkbox-label {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 10px;
            cursor: pointer;
            font-size: 14px;
            color: #333;
        }

        .checkbox-label input[type="checkbox"] {
            width: 16px;
            height: 16px;
        }

        /* Watermark Grid */
        .watermark-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-left: 24px;
            margin-bottom: 15px;
        }

        .help-text {
            font-size: 12px;
            color: #666;
            margin-top: 5px;
            margin-left: 24px;
        }

        .help-link {
            color: #4285f4;
            text-decoration: none;
        }

        /* Start Button */
        .start-chroma-btn {
            width: 200px;
            background: linear-gradient(135deg, #48bb78 0%, #38a169 100%);
            color: white;
            border: none;
            padding: 14px 28px;
            border-radius: 50px;
            font-size: 18px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            margin: 30px auto 0;
            display: block;
            box-shadow: 0 4px 15px rgba(72, 187, 120, 0.4);
            position: relative;
            overflow: hidden;
        }

        .start-chroma-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.3), transparent);
            transition: left 0.5s;
        }

        .start-chroma-btn:hover::before {
            left: 100%;
        }

        .start-chroma-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(72, 187, 120, 0.5);
        }

        /* Progress Overlay */
        .progress-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .progress-modal {
            background: white;
            border-radius: 20px;
            padding: 40px;
            max-width: 500px;
            width: 90%;
            box-shadow: 0 20px 50px rgba(0, 0, 0, 0.3);
        }

        .progress-title {
            font-size: 20px;
            color: #333;
            margin-bottom: 20px;
            text-align: center;
        }

        .progress-bar-container {
            background: #e0e0e0;
            border-radius: 10px;
            height: 20px;
            overflow: hidden;
            margin-bottom: 20px;
        }

        .progress-bar {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            height: 100%;
            width: 0%;
            transition: width 0.3s;
            position: relative;
            overflow: hidden;
        }

        .progress-bar::after {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.3), transparent);
            animation: shimmer 2s infinite;
        }

        @keyframes shimmer {
            0% { left: -100%; }
            100% { left: 100%; }
        }

        .progress-text {
            text-align: center;
            color: #666;
            font-size: 14px;
        }

        /* Result Section */
        .result-section {
            display: none;
            margin-top: 30px;
        }

        .result-title {
            font-size: 18px;
            color: #333;
            margin-bottom: 20px;
            text-align: center;
        }

        .result-container {
            background: #f5f5f5;
            border: 2px solid #e0e0e0;
            border-radius: 16px;
            padding: 20px;
            text-align: center;
        }

        .processed-frames-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 10px;
            margin-bottom: 20px;
        }

        .processed-frame-item {
            position: relative;
            border: 2px solid #e2e8f0;
            border-radius: 12px;
            overflow: hidden;
            background: white;
            box-shadow: 0 2px 8px rgba(0,0,0,0.08);
            padding: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 150px;
        }

        .processed-frame-img {
            width: 100%;
            height: 100%;
            max-width: 200px;
            max-height: 200px;
            object-fit: contain;
            display: block;
            
            /* Checkerboard background to show transparency */
            background-image: 
                linear-gradient(45deg, #f0f0f0 25%, transparent 25%),
                linear-gradient(-45deg, #f0f0f0 25%, transparent 25%),
                linear-gradient(45deg, transparent 75%, #f0f0f0 75%),
                linear-gradient(-45deg, transparent 75%, #f0f0f0 75%);
            background-size: 10px 10px;
            background-position: 0 0, 0 5px, 5px -5px, -5px 0px;
        }

        .result-actions {
            margin-top: 20px;
            display: flex;
            justify-content: center;
            gap: 15px;
        }

        .download-result-btn {
            background: linear-gradient(135deg, #48bb78 0%, #38a169 100%);
            color: white;
            border: none;
            padding: 12px 30px;
            border-radius: 50px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 4px 15px rgba(72, 187, 120, 0.4);
        }

        .download-result-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(72, 187, 120, 0.5);
        }

        /* Loading State */
        .loading {
            display: inline-block;
            width: 16px;
            height: 16px;
            border: 2px solid #f3f3f3;
            border-top: 2px solid #4285f4;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        .extract-btn span,
        .upload-btn span,
        .start-chroma-btn span {
            display: inline-flex;
            align-items: center;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Responsive */
        @media (max-width: 768px) {
            .main-content {
                grid-template-columns: 1fr;
            }
            
            .frames-grid,
            .processed-frames-grid {
                grid-template-columns: repeat(3, 1fr);
            }
            
            .stats-grid {
                grid-template-columns: repeat(2, 1fr);
            }
            
            .method-cards {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <!-- Header -->
    <div class="header">
        <div class="header-content">
            <div class="logo-section">
                <div class="logo">
                    <div class="logo-icon">🎬</div>
                    <span>JiangKing</span>
                </div>
            </div>
            <div class="nav-section">
                <a href="#" class="nav-link">
                    <span class="nav-icon">⭐</span>
                    <span>关注我</span>
                </a>
            </div>
        </div>
    </div>

    <!-- Main Container -->
    <div class="container">
        <div style="text-align: center;">
            <p class="subtitle">🎥 上传视频，自动提取帧并进行抠图处理，每帧独立保存为PNG图片</p>
        </div>
        
        <!-- Step 1: Upload and Extract -->
        <div class="content-wrapper" id="uploadPage">
            <div class="upload-section">
                <div class="upload-title">📂 选择视频文件</div>
                
                <div class="main-content">
                    <!-- Upload Area -->
                    <div class="upload-area" id="uploadArea">
                        <div class="upload-icon">📹</div>
                        <div class="upload-text">拖放视频到这里或</div>
                        <button class="upload-btn">
                            <span>📁</span>
                            <span>选择文件</span>
                        </button>
                        <input type="file" id="fileInput" class="file-input" accept="video/*">
                    </div>
                    
                    <!-- Video Preview -->
                    <div class="video-preview" id="videoPreview">
                        <video id="videoElement"></video>
                        <div class="video-controls">
                            <button class="play-btn" id="playBtn">▶</button>
                            <div class="time-display">
                                <span id="currentTime">0:00</span> / <span id="duration">0:00</span>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- File Info -->
                <div class="file-info" id="fileInfo">
                    <span>已选择: <span id="fileName">--</span></span>
                    <span>大小: <span id="fileSize">--</span> | 时长: <span id="fileDuration">--</span></span>
                    <button class="reset-btn" id="resetBtn">重置</button>
                </div>
                
                <!-- Segment Selection -->
                <div class="segment-section" id="segmentSection">
                    <div class="segment-header">
                        <span class="segment-icon">🎬</span>
                        <span class="segment-title">所选片段预览</span>
                    </div>
                    
                    <div class="segment-preview">
                        <div class="preview-video">
                            <video id="previewVideo"></video>
                            <div class="preview-controls">
                                <button class="play-btn" id="previewPlayBtn">▶</button>
                                <span class="time-display" id="previewTimeDisplay">0:00 / 0:01</span>
                            </div>
                        </div>
                        <div class="segment-info">
                            🎬 循环播放所选片段 (仅 <span id="segmentLength">0:01.0</span>)
                            <br>
                            💡 此处会自动循环播放您选择的视频片段，方便您查看要提取帧的内容
                        </div>
                    </div>
                    
                    <!-- Timeline -->
                    <div class="timeline-container">
                        <div class="timeline-label">
                            <span>🎬 拖动选择视频片段</span>
                            <span>总时长: <span id="totalDuration">0:00</span></span>
                        </div>
                        
                        <div class="timeline-wrapper">
                            <div class="timeline-slider" id="timelineSlider">
                                <canvas class="timeline-waveform" id="waveformCanvas"></canvas>
                                <div class="timeline-progress" id="timelineProgress"></div>
                                <div class="timeline-preview-line" id="previewLine"></div>
                                <div class="timeline-selection" id="timelineSelection">
                                    <div class="timeline-time-tooltip" id="selectionTooltip">0:00 - 0:01</div>
                                </div>
                                <div class="timeline-handle start" id="startHandle">
                                    <div class="timeline-time-tooltip" id="startTooltip">0:00</div>
                                </div>
                                <div class="timeline-handle end" id="endHandle">
                                    <div class="timeline-time-tooltip" id="endTooltip">0:01</div>
                                </div>
                            </div>
                            <div class="timeline-ruler" id="timelineRuler"></div>
                        </div>
                        
                        <div class="timeline-info">
                            <div class="timeline-info-item">
                                <div class="timeline-info-label">开始时间</div>
                                <div class="timeline-info-value" id="startTime">0:00.0</div>
                            </div>
                            <div class="timeline-info-item">
                                <div class="timeline-info-label">片段长度</div>
                                <div class="timeline-info-value" id="durationTime">0:01.0</div>
                            </div>
                            <div class="timeline-info-item">
                                <div class="timeline-info-label">结束时间</div>
                                <div class="timeline-info-value" id="endTime">0:01.0</div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Quick Select -->
                    <div class="quick-select">
                        <span class="quick-select-label">快速选择片段长度：</span>
                        <button class="time-btn" data-duration="0.5">0.5秒</button>
                        <button class="time-btn active" data-duration="1">1秒</button>
                        <button class="time-btn" data-duration="2">2秒</button>
                        <button class="time-btn" data-duration="3">3秒</button>
                        <button class="reset-btn" id="resetSegmentBtn" style="margin-left: auto;">重置为开头1秒</button>
                    </div>
                    
                    <!-- Timeline Tips -->
                    <div class="help-text" style="margin-top: 15px; background: #f8f9fa; padding: 10px; border-radius: 8px;">
                        💡 <strong>时间轴操作提示：</strong>
                        <br>• 拖动两端手柄调整片段起止时间
                        <br>• 拖动中间区域移动整个片段位置
                        <br>• 单击时间轴快速定位，双击重置为1秒
                        <br>• 键盘快捷键：←→ 移动片段，[ ] 调整长度，空格播放/暂停
                        <br>• 按住 Shift 键进行精细调整（0.1秒步进）
                        <br>• 按住 Ctrl/Cmd 键拖动时自动对齐到0.1秒网格
                    </div>
                </div>
                
                <!-- Video Stats -->
                <div class="stats-grid" id="statsGrid">
                    <div class="stat-item">
                        <div class="stat-label">画面片段:</div>
                        <div class="stat-value" id="statSegment">0.00s - 1.00s</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">视频时长:</div>
                        <div class="stat-value" id="statDuration">0:00</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">视频尺寸:</div>
                        <div class="stat-value small" id="statResolution">无</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">预计提取:</div>
                        <div class="stat-value" id="statFrames">20 帧</div>
                    </div>
                </div>
                
                <!-- Extract Settings -->
                <div class="extract-settings" id="extractSettings">
                    <div class="setting-row">
                        <span class="setting-label">每秒提取帧数</span>
                        <div class="setting-input">
                            <input type="number" class="input-number" id="fps" value="20" min="1" max="30">
                            <span id="fpsInfo">帧/秒 (建议5-30帧/秒) - 预计提取 20 帧</span>
                        </div>
                    </div>
                    
                    <div class="setting-row">
                        <span class="setting-label">提示：帧数越多，动画越细腻，但处理时间更长</span>
                    </div>
                    
                    <button class="extract-btn" id="extractBtn">
                        <span>🎬</span>
                        <span>开始提取帧</span>
                    </button>
                </div>
            </div>
        </div>
        
        <!-- Step 2: Frame Selection -->
        <div class="content-wrapper frame-selection" id="framePage">
            <div class="frame-header">
                <h2 class="frame-title">选择要处理的帧 (<span id="selectedCount">0</span>/<span id="totalFrameCount">0</span>)</h2>
                <div class="frame-actions">
                    <button class="action-btn secondary" id="backToUploadBtn">← 返回上传</button>
                    <button class="action-btn secondary" id="selectAllBtn">全选</button>
                    <button class="action-btn secondary" id="deselectAllBtn">全不选</button>
                    <button class="action-btn success" id="downloadFramesBtn">打包下载原图 (0)</button>
                </div>
            </div>
            
            <div class="frames-grid" id="framesGrid">
                <!-- Frames will be generated here -->
            </div>
            
            <!-- Quick Preview -->
            <div class="quick-preview">
                <div class="preview-header">
                    <span>⚡</span>
                    <span class="preview-title">批量选择技巧: 点击一个帧后，按住 Shift 键再点击另一个帧，可以批量选择/取消选择中间的所有帧</span>
                </div>
                
                <div class="preview-header">
                    <span>🖼️</span>
                    <span class="preview-title">快速预览选中的帧</span>
                </div>
                
                <div class="preview-main">
                    <div class="preview-frame">
                        <img id="previewFrameImg" src="" alt="Frame preview">
                        <div class="frame-number">1 / <span id="frameTotal">0</span></div>
                    </div>
                </div>
                
                <div class="preview-slider">
                    <div class="slider-container">
                        <input type="range" class="slider" id="frameSlider" min="1" max="1" value="1">
                        <div class="slider-labels">
                            <span>第一帧</span>
                            <span id="currentFrameLabel">第 1 帧</span>
                            <span>第 <span id="lastFrameLabel">1</span> 帧</span>
                        </div>
                    </div>
                </div>
                

            </div>
            
            <!-- Chroma Key Settings -->
            <div class="chroma-settings">
                <h3 class="settings-title">
                    <span>🎨</span>
                    <span>抠图质量设置</span>
                </h3>
                
                <div class="method-selection">
                    <div class="method-label">抠图方法选择</div>
                    <div class="method-cards">
                        <div class="method-card active" data-method="chroma">
                            <label>
                                <input type="radio" name="method" value="chroma" checked>
                                <span class="method-name">🎬 绿幕抠图 (Chroma Key) ⭐</span>
                                <div class="method-desc">适合纯色背景、绿幕蓝幕、单色图像</div>
                            </label>
                        </div>
                        <div class="method-card" data-method="ai">
                            <label>
                                <input type="radio" name="method" value="ai">
                                <span class="method-name">🤖 AI人像分割 (MediaPipe)</span>
                                <div class="method-desc">适合自然场景、复杂背景</div>
                            </label>
                        </div>
                    </div>
                </div>
                
                <div class="setting-group">
                    <div class="setting-header">
                        <span class="setting-name">背景颜色类型</span>
                        <span class="setting-value">自动检测背景色 ⭐</span>
                    </div>
                    <div class="color-selector">
                        <button class="color-option active">🎨 自动检测背景色 ⭐</button>
                    </div>
                    <div class="help-text" style="margin-top: 10px;">
                        检测到的背景色: <span id="detectedBgColor" style="display: inline-block; width: 20px; height: 20px; border: 1px solid #ccc; vertical-align: middle; margin-left: 5px;"></span>
                        <span id="bgColorRGB" style="margin-left: 5px; font-family: monospace;"></span>
                    </div>
                </div>
                
                <div class="setting-group">
                    <div class="setting-header">
                        <span class="setting-name">颜色容差: <span id="toleranceValue">0.08</span></span>
                        <span class="setting-value"></span>
                    </div>
                    <input type="range" class="tolerance-slider slider" id="toleranceSlider" min="0" max="1" step="0.01" value="0.08">
                    <div class="slider-scale">
                        <span>宽松 (可能残留)</span>
                        <span>严格 (可能过度)</span>
                    </div>
                </div>
                
                <div class="checkbox-group">
                    <label class="checkbox-label">
                        <input type="checkbox" id="smoothEdges" checked>
                        <span>边缘平滑</span>
                    </label>
                </div>

                <div class="checkbox-group">
                    <label class="checkbox-label">
                        <input type="checkbox" id="autoCrop" checked>
                        <span>✂️ 自动裁剪透明边缘 ⭐</span>
                    </label>
                    <div class="help-text">
                        💡 自动裁剪掉图片周围的透明区域，让抠图后的内容更紧凑。建议开启此选项以获得更好的展示效果。
                    </div>
                </div>
                
                <div class="checkbox-group">
                    <label class="checkbox-label">
                        <input type="checkbox" id="removeWatermark">
                        <span>💧 清除四角水印 ⭐</span>
                    </label>
                    <div class="watermark-grid" id="watermarkGrid" style="display: none;">
                        <label class="checkbox-label">
                            <input type="checkbox" id="watermarkTL" checked>
                            <span>📍 左上角</span>
                        </label>
                        <label class="checkbox-label">
                            <input type="checkbox" id="watermarkTR" checked>
                            <span>📍 右上角</span>
                        </label>
                        <label class="checkbox-label">
                            <input type="checkbox" id="watermarkBL" checked>
                            <span>📍 左下角</span>
                        </label>
                        <label class="checkbox-label">
                            <input type="checkbox" id="watermarkBR" checked>
                            <span>📍 右下角</span>
                        </label>
                    </div>
                    <div class="help-text">
                        💡 自动检测和清除各个角落的水印、标记或Logo。算法会分析角落区域的颜色透明度分布，识别可能的水印后自动清除。
                    </div>
                </div>
                
                <div class="setting-group" id="watermarkSizeGroup" style="display: none;">
                    <div class="setting-header">
                        <span class="setting-name">🎯 检测区域大小: <span id="watermarkSizeValue">12.5</span>% (约 1/8)</span>
                    </div>
                    <input type="range" class="slider" id="watermarkSizeSlider" min="5" max="30" value="12.5" step="0.5">
                    <div class="slider-scale">
                        <span>小区域 (5%)</span>
                        <span>默认 12.5%</span>
                        <span>大区域 (30%)</span>
                    </div>
                    <div class="help-text">
                        💡 调整每个角落检测区域的大小。水印较小时减小比例，水印较大时增大比例。
                    </div>
                </div>
                
                <div class="help-text" style="margin-top: 20px;">
                    💡 选择建议: 绿幕/单色背景推荐使用绿幕方法。当前设置已根据实际效果优化。
                    <br><br>
                    ⚡ <strong>针对白色背景的优化提示：</strong>
                    <br>• 默认容差值0.08适合大多数白色背景
                    <br>• 如果边缘有白色残留，请降低容差值（建议0.03-0.08）
                    <br>• 如果主体有白色部分被误删，请提高容差值（建议0.08-0.15）
                    <br>• 确保开启"边缘平滑"选项以获得更自然的边缘
                    <br>• 对于复杂背景，建议使用AI人像分割方法
                    <br><br>
                    ✂️ <strong>自动裁剪功能：</strong>
                    <br>• 开启后会自动去除图片周围的透明区域
                    <br>• 让抠图后的内容更加紧凑，节省空间
                    <br>• 裁剪时会保留5像素的安全边距
                    <br>• 特别适合制作精灵图或需要紧密排列的素材
                    <br><br>
                    📌 <strong>检查透明效果：</strong>
                    <br>• 结果预览中的棋盘格背景表示透明区域
                    <br>• 使用"预览当前帧抠图效果"按钮可以快速测试设置
                    <br>• 调整容差值后，先预览单帧效果再批量处理
                    <br><br>
                    自动检测背景色逻辑：算法会分析图像四个角落的颜色分布，使用聚类算法找出最可能的背景色。对于白色背景，还会额外考虑亮度因素。<a href="#" class="help-link">查看帮助</a>
                </div>
                
                <button class="start-chroma-btn" id="startChromaBtn">
                    <span>✨</span>
                    <span>开始抠图(0)</span>
                </button>
                
                <div style="text-align: center; margin-top: 15px;">
                    <button class="control-btn" id="previewChromaBtn" style="padding: 10px 20px;">
                        <span>👁️ 预览当前帧抠图效果</span>
                    </button>
                </div>
            </div>
            
            <!-- Result Section -->
            <div class="result-section" id="resultSection">
                <h3 class="result-title">🎉 抠图完成！处理后的透明PNG图片</h3>
                <div class="result-container">
                    <div class="processed-frames-grid" id="processedFramesGrid">
                        <!-- Processed frames will be displayed here -->
                    </div>
                    <div class="result-actions">
                        <button class="download-result-btn" id="downloadResultBtn">
                            <span>💾</span>
                            <span>打包下载所有PNG</span>
                        </button>
                        <button class="action-btn secondary" id="backToFramesBtn">
                            <span>🔄</span>
                            <span>重新选择帧</span>
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Progress Overlay -->
    <div class="progress-overlay" id="progressOverlay">
        <div class="progress-modal">
            <h3 class="progress-title" id="progressTitle">正在处理...</h3>
            <div class="progress-bar-container">
                <div class="progress-bar" id="progressBar"></div>
            </div>
            <div class="progress-text" id="progressText">正在准备...</div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script>
        // Initialize the application
        class VideoToFrames {
            constructor() {
                this.video = null;
                this.frames = [];
                this.selectedFrames = new Set();
                this.processedFrames = [];
                this.currentPage = 'upload';
                this.segmentStart = 0;
                this.segmentDuration = 1;
                this.lastClickedFrame = null;
                this.previewInterval = null;
                this.shiftKeyPressed = false;
                this.snapToGrid = false;
                this.timelineDrag = {
                    isDragging: false,
                    dragType: null,
                    dragStartX: 0,
                    dragStartSegmentStart: 0,
                    dragStartSegmentEnd: 0,
                    lastUpdateTime: 0
                };
                
                this.settings = {
                    method: 'chroma',
                    tolerance: 0.08,
                    smoothEdges: true,
                    removeWatermark: false,
                    watermarkCorners: {
                        TL: true,
                        TR: true,
                        BL: true,
                        BR: true
                    },
                    watermarkSize: 12.5,
                    autoCrop: true
                };
                
                this.initializeUI();
            }

            initializeUI() {
                // File upload handlers
                const uploadArea = document.getElementById('uploadArea');
                const fileInput = document.getElementById('fileInput');
                const uploadBtn = uploadArea.querySelector('.upload-btn');
                
                uploadBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    fileInput.click();
                });
                
                uploadArea.addEventListener('click', (e) => {
                    if (!e.target.closest('.upload-btn')) {
                        fileInput.click();
                    }
                });
                fileInput.addEventListener('change', (e) => this.handleFileSelect(e));
                
                // Drag and drop
                uploadArea.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    uploadArea.style.borderColor = '#667eea';
                    uploadArea.style.background = 'linear-gradient(135deg, #f0f4ff 0%, #e9ecff 100%)';
                });
                
                uploadArea.addEventListener('dragleave', () => {
                    uploadArea.style.borderColor = '#cbd5e0';
                    uploadArea.style.background = 'linear-gradient(135deg, #f8fafc 0%, #f0f4f8 100%)';
                });
                
                uploadArea.addEventListener('drop', (e) => {
                    e.preventDefault();
                    uploadArea.style.borderColor = '#cbd5e0';
                    uploadArea.style.background = 'linear-gradient(135deg, #f8fafc 0%, #f0f4f8 100%)';
                    const files = e.dataTransfer.files;
                    if (files.length > 0) {
                        this.loadVideo(files[0]);
                    }
                });
                
                // Video controls
                document.getElementById('playBtn').addEventListener('click', () => this.toggleVideoPlay());
                document.getElementById('previewPlayBtn').addEventListener('click', () => this.togglePreviewPlay());
                
                // Reset button
                document.getElementById('resetBtn').addEventListener('click', () => this.resetVideo());
                
                // Timeline interaction
                this.initializeTimeline();
                
                // Quick time selection
                document.querySelectorAll('.time-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        document.querySelectorAll('.time-btn').forEach(b => b.classList.remove('active'));
                        e.target.classList.add('active');
                        const duration = parseFloat(e.target.dataset.duration);
                        this.setSegmentDuration(duration);
                    });
                });
                
                // Reset segment button
                document.getElementById('resetSegmentBtn').addEventListener('click', () => {
                    this.segmentStart = 0;
                    this.segmentDuration = 1;
                    document.querySelectorAll('.time-btn').forEach(b => b.classList.remove('active'));
                    document.querySelector('.time-btn[data-duration="1"]').classList.add('active');
                    this.updateSegmentDisplay();
                    this.updatePreviewPosition();
                });
                
                // Extract button
                document.getElementById('extractBtn').addEventListener('click', () => {
                    this.extractFrames();
                });
                
                // Frame selection page handlers
                document.getElementById('backToUploadBtn').addEventListener('click', () => {
                    document.getElementById('framePage').style.display = 'none';
                    document.getElementById('uploadPage').style.display = 'block';
                    this.currentPage = 'upload';
                });
                
                document.getElementById('selectAllBtn').addEventListener('click', () => {
                    this.selectAllFrames();
                });
                
                document.getElementById('deselectAllBtn').addEventListener('click', () => {
                    this.deselectAllFrames();
                });
                
                document.getElementById('downloadFramesBtn').addEventListener('click', () => {
                    this.downloadSelectedFrames();
                });
                
                // Frame preview controls
                document.getElementById('frameSlider').addEventListener('input', (e) => {
                    this.updateFramePreview(parseInt(e.target.value) - 1);
                });
                
                // Method selection
                document.querySelectorAll('.method-card').forEach(card => {
                    card.addEventListener('click', () => {
                        document.querySelectorAll('.method-card').forEach(c => c.classList.remove('active'));
                        card.classList.add('active');
                        card.querySelector('input[type="radio"]').checked = true;
                        this.settings.method = card.querySelector('input[type="radio"]').value;
                    });
                });
                
                // Settings
                document.getElementById('toleranceSlider').addEventListener('input', (e) => {
                    this.settings.tolerance = parseFloat(e.target.value);
                    document.getElementById('toleranceValue').textContent = e.target.value;
                });
                
                document.getElementById('smoothEdges').addEventListener('change', (e) => {
                    this.settings.smoothEdges = e.target.checked;
                });

                document.getElementById('autoCrop').addEventListener('change', (e) => {
                    this.settings.autoCrop = e.target.checked;
                });
                
                // Watermark settings
                document.getElementById('removeWatermark').addEventListener('change', (e) => {
                    this.settings.removeWatermark = e.target.checked;
                    document.getElementById('watermarkGrid').style.display = e.target.checked ? 'grid' : 'none';
                    document.getElementById('watermarkSizeGroup').style.display = e.target.checked ? 'block' : 'none';
                });
                
                ['TL', 'TR', 'BL', 'BR'].forEach(corner => {
                    document.getElementById(`watermark${corner}`).addEventListener('change', (e) => {
                        this.settings.watermarkCorners[corner] = e.target.checked;
                    });
                });
                
                document.getElementById('watermarkSizeSlider').addEventListener('input', (e) => {
                    this.settings.watermarkSize = parseFloat(e.target.value);
                    document.getElementById('watermarkSizeValue').textContent = e.target.value;
                });
                
                // Start chroma key
                document.getElementById('startChromaBtn').addEventListener('click', () => {
                    this.startChromaKey();
                });
                
                // Preview chroma key
                document.getElementById('previewChromaBtn').addEventListener('click', () => {
                    this.previewChromaKey();
                });
                
                // Result actions
                document.getElementById('downloadResultBtn').addEventListener('click', () => {
                    this.downloadResult();
                });
                
                document.getElementById('backToFramesBtn').addEventListener('click', () => {
                    document.getElementById('resultSection').style.display = 'none';
                });
                
                // FPS input
                document.getElementById('fps').addEventListener('input', (e) => {
                    this.updateEstimatedFrames();
                });
                
                // Keyboard shortcuts
                document.addEventListener('keydown', (e) => {
                    // Shift key for batch selection
                    if (e.key === 'Shift') {
                        this.shiftKeyPressed = true;
                    }
                    
                    // Timeline shortcuts (only on upload page)
                    if (this.currentPage !== 'upload' || !this.video) return;
                    
                    const step = e.shiftKey ? 0.1 : 1; // Shift for fine control
                    
                    switch(e.key) {
                        case 'ArrowLeft':
                            e.preventDefault();
                            this.segmentStart = Math.max(0, this.segmentStart - step);
                            this.updateSegmentDisplay();
                            this.updatePreviewPosition();
                            break;
                        case 'ArrowRight':
                            e.preventDefault();
                            this.segmentStart = Math.min(this.video.duration - this.segmentDuration, this.segmentStart + step);
                            this.updateSegmentDisplay();
                            this.updatePreviewPosition();
                            break;
                        case '[':
                            e.preventDefault();
                            this.segmentDuration = Math.max(0.1, this.segmentDuration - step);
                            this.updateSegmentDisplay();
                            this.updatePreviewPosition();
                            break;
                        case ']':
                            e.preventDefault();
                            this.segmentDuration = Math.min(this.video.duration - this.segmentStart, this.segmentDuration + step);
                            this.updateSegmentDisplay();
                            this.updatePreviewPosition();
                            break;
                        case ' ':
                            e.preventDefault();
                            this.togglePreviewPlay();
                            break;
                    }
                });
                
                document.addEventListener('keyup', (e) => {
                    if (e.key === 'Shift') {
                        this.shiftKeyPressed = false;
                    }
                });
            }

            initializeTimeline() {
                const timelineSlider = document.getElementById('timelineSlider');
                const startHandle = document.getElementById('startHandle');
                const endHandle = document.getElementById('endHandle');
                const timelineSelection = document.getElementById('timelineSelection');
                
                // Drag state
                this.timelineDrag = {
                    isDragging: false,
                    dragType: null, // 'start', 'end', 'selection'
                    dragStartX: 0,
                    dragStartSegmentStart: 0,
                    dragStartSegmentEnd: 0,
                    lastUpdateTime: 0
                };
                
                // Helper function to get time from mouse position
                const getTimeFromMouseX = (clientX) => {
                    const rect = timelineSlider.getBoundingClientRect();
                    const x = Math.max(0, Math.min(clientX - rect.left, rect.width));
                    const percentage = x / rect.width;
                    return this.video.duration * percentage;
                };
                
                // Handle mouse down on handles and selection
                const handleMouseDown = (e, type) => {
                    if (!this.video) return;
                    
                    this.timelineDrag.isDragging = true;
                    this.timelineDrag.dragType = type;
                    this.timelineDrag.dragStartX = e.clientX;
                    this.timelineDrag.dragStartSegmentStart = this.segmentStart;
                    this.timelineDrag.dragStartSegmentEnd = this.segmentStart + this.segmentDuration;
                    
                    e.preventDefault();
                    e.stopPropagation();
                    
                    // Add visual feedback
                    document.body.style.cursor = type === 'selection' ? 'grabbing' : 'ew-resize';
                    timelineSlider.classList.add('dragging');
                    
                    if (type === 'selection') {
                        timelineSelection.classList.add('dragging');
                    } else if (type === 'start') {
                        startHandle.classList.add('dragging');
                    } else if (type === 'end') {
                        endHandle.classList.add('dragging');
                    }
                    
                    // Show tooltips during drag
                    document.getElementById('startTooltip').style.opacity = '1';
                    document.getElementById('endTooltip').style.opacity = '1';
                    document.getElementById('selectionTooltip').style.opacity = '1';
                };
                
                // Handle clicks on timeline elements
                startHandle.addEventListener('mousedown', (e) => handleMouseDown(e, 'start'));
                endHandle.addEventListener('mousedown', (e) => handleMouseDown(e, 'end'));
                
                timelineSelection.addEventListener('mousedown', (e) => {
                    // Only handle if clicking on the selection bar itself
                    if (e.target === timelineSelection) {
                        handleMouseDown(e, 'selection');
                    }
                });
                
                // Handle timeline click for quick positioning
                timelineSlider.addEventListener('mousedown', (e) => {
                    if (this.timelineDrag.isDragging || !this.video) return;
                    if (e.target !== timelineSlider && !e.target.classList.contains('timeline-waveform')) return;
                    
                    const clickTime = getTimeFromMouseX(e.clientX);
                    
                    // Check if click is within current selection
                    if (clickTime >= this.segmentStart && clickTime <= this.segmentStart + this.segmentDuration) {
                        // Start dragging the selection
                        handleMouseDown(e, 'selection');
                    } else {
                        // Move selection to click point
                        const halfDuration = this.segmentDuration / 2;
                        this.segmentStart = Math.max(0, Math.min(clickTime - halfDuration, this.video.duration - this.segmentDuration));
                        
                        this.updateSegmentDisplay();
                        this.updatePreviewPosition();
                        
                        // Start dragging after repositioning
                        handleMouseDown(e, 'selection');
                    }
                });
                
                // Mouse move handler
                const handleMouseMove = (e) => {
                    if (!this.timelineDrag.isDragging || !this.video) return;
                    
                    // Throttle updates for performance
                    const now = Date.now();
                    if (now - this.timelineDrag.lastUpdateTime < 16) return; // ~60fps
                    this.timelineDrag.lastUpdateTime = now;
                    
                    const currentTime = getTimeFromMouseX(e.clientX);
                    const dragStartTime = getTimeFromMouseX(this.timelineDrag.dragStartX);
                    const deltaTime = currentTime - dragStartTime;
                    
                    if (this.timelineDrag.dragType === 'start') {
                        // Dragging start handle
                        const newStart = Math.max(0, Math.min(
                            this.timelineDrag.dragStartSegmentStart + deltaTime,
                            this.timelineDrag.dragStartSegmentEnd - 0.1 // Minimum duration 0.1s
                        ));
                        
                        this.segmentStart = newStart;
                        this.segmentDuration = this.timelineDrag.dragStartSegmentEnd - newStart;
                        
                    } else if (this.timelineDrag.dragType === 'end') {
                        // Dragging end handle
                        const newEnd = Math.max(
                            this.timelineDrag.dragStartSegmentStart + 0.1, // Minimum duration 0.1s
                            Math.min(this.timelineDrag.dragStartSegmentEnd + deltaTime, this.video.duration)
                        );
                        
                        this.segmentDuration = newEnd - this.segmentStart;
                        
                    } else if (this.timelineDrag.dragType === 'selection') {
                        // Dragging entire selection
                        const newStart = Math.max(0, Math.min(
                            this.timelineDrag.dragStartSegmentStart + deltaTime,
                            this.video.duration - this.segmentDuration
                        ));
                        
                        this.segmentStart = newStart;
                    }
                    
                    // Apply snap-to-grid if enabled
                    if (this.snapToGrid) {
                        const snapInterval = 0.1; // Snap to 0.1 second intervals
                        if (this.timelineDrag.dragType === 'start') {
                            this.segmentStart = Math.round(this.segmentStart / snapInterval) * snapInterval;
                            this.segmentDuration = this.timelineDrag.dragStartSegmentEnd - this.segmentStart;
                        } else if (this.timelineDrag.dragType === 'end') {
                            const newEnd = this.segmentStart + this.segmentDuration;
                            const snappedEnd = Math.round(newEnd / snapInterval) * snapInterval;
                            this.segmentDuration = snappedEnd - this.segmentStart;
                        } else if (this.timelineDrag.dragType === 'selection') {
                            this.segmentStart = Math.round(this.segmentStart / snapInterval) * snapInterval;
                        }
                    }
                    
                    // Update display immediately without animations
                    this.updateSegmentDisplay();
                    // Don't update preview position during drag to avoid lag
                };
                
                // Mouse up handler
                const handleMouseUp = () => {
                    if (!this.timelineDrag.isDragging) return;
                    
                    this.timelineDrag.isDragging = false;
                    this.timelineDrag.dragType = null;
                    
                    // Reset visual feedback
                    document.body.style.cursor = '';
                    timelineSlider.classList.remove('dragging');
                    timelineSelection.classList.remove('dragging');
                    startHandle.classList.remove('dragging');
                    endHandle.classList.remove('dragging');
                    
                    // Update preview position after drag ends
                    this.updatePreviewPosition();
                    
                    // Hide tooltips after a delay
                    setTimeout(() => {
                        if (!this.timelineDrag.isDragging) {
                            document.getElementById('startTooltip').style.opacity = '';
                            document.getElementById('endTooltip').style.opacity = '';
                            document.getElementById('selectionTooltip').style.opacity = '';
                        }
                    }, 500);
                };
                
                // Add global mouse event listeners
                document.addEventListener('mousemove', handleMouseMove);
                document.addEventListener('mouseup', handleMouseUp);
                
                // Handle mouse leave to ensure drag ends
                document.addEventListener('mouseleave', (e) => {
                    if (e.clientY <= 0 || e.clientX <= 0 || 
                        e.clientX >= window.innerWidth || e.clientY >= window.innerHeight) {
                        handleMouseUp();
                    }
                });
                
                // Preview line on hover
                timelineSlider.addEventListener('mousemove', (e) => {
                    if (this.timelineDrag.isDragging || !this.video) return;
                    
                    const rect = timelineSlider.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const percentage = (x / rect.width) * 100;
                    
                    const previewLine = document.getElementById('previewLine');
                    previewLine.style.left = percentage + '%';
                    previewLine.classList.add('active');
                    
                    // Create or update time tooltip
                    let tooltip = previewLine.querySelector('.preview-time-tooltip');
                    if (!tooltip) {
                        tooltip = document.createElement('div');
                        tooltip.className = 'preview-time-tooltip';
                        previewLine.appendChild(tooltip);
                    }
                    
                    const time = getTimeFromMouseX(e.clientX);
                    tooltip.textContent = this.formatTime(time);
                    tooltip.style.opacity = '1';
                });
                
                timelineSlider.addEventListener('mouseleave', () => {
                    if (!this.timelineDrag.isDragging) {
                        const previewLine = document.getElementById('previewLine');
                        previewLine.classList.remove('active');
                        const tooltip = previewLine.querySelector('.preview-time-tooltip');
                        if (tooltip) {
                            tooltip.style.opacity = '0';
                        }
                    }
                });
                
                // Touch support for mobile
                let touchStartX = 0;
                
                const handleTouchStart = (e, type) => {
                    if (!this.video || e.touches.length !== 1) return;
                    
                    const touch = e.touches[0];
                    touchStartX = touch.clientX;
                    
                    // Simulate mouse down
                    const mouseEvent = new MouseEvent('mousedown', {
                        clientX: touch.clientX,
                        clientY: touch.clientY,
                        bubbles: true
                    });
                    
                    handleMouseDown(mouseEvent, type);
                };
                
                const handleTouchMove = (e) => {
                    if (!this.timelineDrag.isDragging || e.touches.length !== 1) return;
                    
                    e.preventDefault();
                    const touch = e.touches[0];
                    
                    // Simulate mouse move
                    const mouseEvent = new MouseEvent('mousemove', {
                        clientX: touch.clientX,
                        clientY: touch.clientY
                    });
                    
                    handleMouseMove(mouseEvent);
                };
                
                const handleTouchEnd = (e) => {
                    e.preventDefault();
                    handleMouseUp();
                };
                
                // Add touch event listeners
                startHandle.addEventListener('touchstart', (e) => handleTouchStart(e, 'start'));
                endHandle.addEventListener('touchstart', (e) => handleTouchStart(e, 'end'));
                timelineSelection.addEventListener('touchstart', (e) => handleTouchStart(e, 'selection'));
                
                document.addEventListener('touchmove', handleTouchMove, { passive: false });
                document.addEventListener('touchend', handleTouchEnd);
                document.addEventListener('touchcancel', handleTouchEnd);
                
                // Double-click to reset selection
                timelineSlider.addEventListener('dblclick', (e) => {
                    if (!this.video) return;
                    
                    // Reset to 1 second at clicked position
                    const clickTime = getTimeFromMouseX(e.clientX);
                    this.segmentDuration = 1;
                    this.segmentStart = Math.max(0, Math.min(clickTime - 0.5, this.video.duration - 1));
                    
                    // Update quick select buttons
                    document.querySelectorAll('.time-btn').forEach(b => b.classList.remove('active'));
                    document.querySelector('.time-btn[data-duration="1"]').classList.add('active');
                    
                    this.updateSegmentDisplay();
                    this.updatePreviewPosition();
                    
                    // Visual feedback with smooth transition
                    const timeline = document.getElementById('timelineSelection');
                    const oldTransition = timeline.style.transition;
                    timeline.style.transition = 'all 0.3s ease-out';
                    
                    const startHandle = document.getElementById('startHandle');
                    const endHandle = document.getElementById('endHandle');
                    const oldStartTransition = startHandle.style.transition;
                    const oldEndTransition = endHandle.style.transition;
                    startHandle.style.transition = 'all 0.3s ease-out';
                    endHandle.style.transition = 'all 0.3s ease-out';
                    
                    setTimeout(() => {
                        timeline.style.transition = oldTransition;
                        startHandle.style.transition = oldStartTransition;
                        endHandle.style.transition = oldEndTransition;
                    }, 300);
                });
                
                // Add snap-to-grid functionality when holding Ctrl/Cmd
                document.addEventListener('keydown', (e) => {
                    if (e.ctrlKey || e.metaKey) {
                        this.snapToGrid = true;
                    }
                });
                
                document.addEventListener('keyup', (e) => {
                    if (!e.ctrlKey && !e.metaKey) {
                        this.snapToGrid = false;
                    }
                });
            }

            handleFileSelect(e) {
                const file = e.target.files[0];
                if (file) {
                    this.loadVideo(file);
                }
            }

            async loadVideo(file) {
                if (!file.type.startsWith('video/')) {
                    alert('请选择有效的视频文件');
                    return;
                }
                
                const videoElement = document.getElementById('videoElement');
                const previewVideo = document.getElementById('previewVideo');
                const url = URL.createObjectURL(file);
                
                videoElement.src = url;
                previewVideo.src = url;
                
                videoElement.addEventListener('loadedmetadata', () => {
                    this.video = videoElement;
                    this.displayVideoInfo(file);
                    document.getElementById('videoPreview').style.display = 'block';
                    document.getElementById('fileInfo').style.display = 'flex';
                    document.getElementById('segmentSection').style.display = 'block';
                    document.getElementById('statsGrid').style.display = 'grid';
                    document.getElementById('extractSettings').style.display = 'block';
                    
                    // Initialize segment position with a slight delay to ensure DOM is ready
                    setTimeout(() => {
                        this.segmentStart = 0;
                        this.segmentDuration = 1;
                        this.updateSegmentDisplay();
                    }, 50);
                    
                    this.updateVideoTime();
                    this.updateEstimatedFrames();
                    this.updateSegmentDisplay();
                    this.setupPreviewLoop();
                    
                    // Generate timeline visuals
                    setTimeout(() => {
                        this.generateWaveform();
                        this.generateTimelineRuler();
                        // Ensure timeline handles are visible after all initialization
                        this.updateSegmentDisplay();
                    }, 100);
                });
                
                videoElement.addEventListener('timeupdate', () => {
                    this.updateVideoTime();
                    
                    // Update timeline progress
                    if (this.video) {
                        const progress = (videoElement.currentTime / this.video.duration) * 100;
                        document.getElementById('timelineProgress').style.width = progress + '%';
                    }
                });
            }

            setupPreviewLoop() {
                const previewVideo = document.getElementById('previewVideo');
                let isLooping = false;
                
                previewVideo.addEventListener('timeupdate', () => {
                    if (!isLooping && previewVideo.currentTime >= this.segmentStart + this.segmentDuration - 0.05) {
                        isLooping = true;
                        previewVideo.currentTime = this.segmentStart;
                        
                        // Reset looping flag after seek completes
                        setTimeout(() => {
                            isLooping = false;
                        }, 100);
                    }
                    
                    // Update preview time display
                    const elapsed = Math.max(0, previewVideo.currentTime - this.segmentStart);
                    const elapsedStr = this.formatDuration(elapsed);
                    const durationStr = this.formatTime(this.segmentDuration);
                    document.getElementById('previewTimeDisplay').textContent = `${elapsedStr} / ${durationStr}`;
                });
                
                // Set initial position
                previewVideo.currentTime = this.segmentStart;
                
                // Handle play/pause state changes
                previewVideo.addEventListener('play', () => {
                    document.getElementById('previewPlayBtn').textContent = '⏸';
                });
                
                previewVideo.addEventListener('pause', () => {
                    document.getElementById('previewPlayBtn').textContent = '▶';
                });
            }

            updatePreviewPosition() {
                // Update preview video position during dragging
                if (this.video && !this.timelineDrag.isDragging) {
                    const previewVideo = document.getElementById('previewVideo');
                    if (previewVideo && !previewVideo.seeking) {
                        previewVideo.currentTime = this.segmentStart;
                    }
                }
            }

            displayVideoInfo(file) {
                document.getElementById('fileName').textContent = file.name;
                document.getElementById('fileSize').textContent = this.formatFileSize(file.size);
                document.getElementById('fileDuration').textContent = this.formatDuration(this.video.duration);
                document.getElementById('totalDuration').textContent = this.formatDuration(this.video.duration);
                
                // Update stats
                document.getElementById('statDuration').textContent = this.formatDuration(this.video.duration);
                document.getElementById('statResolution').textContent = `${this.video.videoWidth}×${this.video.videoHeight}`;
            }

            formatFileSize(bytes) {
                const mb = bytes / (1024 * 1024);
                return mb.toFixed(2) + ' MB';
            }

            formatDuration(seconds) {
                const mins = Math.floor(seconds / 60);
                const secs = Math.floor(seconds % 60);
                return `${mins}:${secs.toString().padStart(2, '0')}`;
            }

            formatTime(seconds) {
                const mins = Math.floor(seconds / 60);
                const secs = (seconds % 60).toFixed(1);
                return `${mins}:${secs.padStart(4, '0')}`;
            }

            updateVideoTime() {
                const video = document.getElementById('videoElement');
                document.getElementById('currentTime').textContent = this.formatDuration(video.currentTime);
                document.getElementById('duration').textContent = this.formatDuration(video.duration);
            }

            toggleVideoPlay() {
                const video = document.getElementById('videoElement');
                const playBtn = document.getElementById('playBtn');
                
                if (video.paused) {
                    video.play();
                    playBtn.textContent = '⏸';
                } else {
                    video.pause();
                    playBtn.textContent = '▶';
                }
            }

            togglePreviewPlay() {
                const video = document.getElementById('previewVideo');
                const playBtn = document.getElementById('previewPlayBtn');
                
                if (video.paused) {
                    video.play();
                    playBtn.textContent = '⏸';
                } else {
                    video.pause();
                    playBtn.textContent = '▶';
                }
            }

            resetVideo() {
                this.currentPage = 'upload';
                location.reload();
            }

            setSegmentDuration(duration) {
                if (this.segmentStart + duration > this.video.duration) {
                    this.segmentStart = Math.max(0, this.video.duration - duration);
                }
                this.segmentDuration = duration;
                this.updateSegmentDisplay();
                this.updatePreviewPosition();
            }

            updateSegmentDisplay() {
                if (!this.video) return;

                // Ensure segment is within bounds
                this.segmentStart = Math.max(0, Math.min(this.segmentStart, this.video.duration - 0.1));
                this.segmentDuration = Math.max(0.1, Math.min(this.segmentDuration, this.video.duration - this.segmentStart));

                // Update timeline visual
                const timeline = document.getElementById('timelineSelection');
                const startHandle = document.getElementById('startHandle');
                const endHandle = document.getElementById('endHandle');

                // Ensure elements exist
                if (!timeline || !startHandle || !endHandle) {
                    console.warn('Timeline elements not found');
                    return;
                }

                const startPercentage = (this.segmentStart / this.video.duration) * 100;
                const widthPercentage = (this.segmentDuration / this.video.duration) * 100;

                // Ensure minimum visual width
                const minVisualWidth = 2; // Minimum 2% width for visibility
                const visualWidthPercentage = Math.max(minVisualWidth, widthPercentage);

                // Force display and positioning
                timeline.style.display = 'block';
                timeline.style.left = startPercentage + '%';
                timeline.style.width = visualWidthPercentage + '%';

                // Position handles at exact edges and ensure they're visible
                const endPercentage = startPercentage + widthPercentage;
                startHandle.style.display = 'flex';
                startHandle.style.left = `calc(${startPercentage}% - 8px)`;
                endHandle.style.display = 'flex';
                endHandle.style.left = `calc(${endPercentage}% - 8px)`;
                
                // Update tooltips
                document.getElementById('startTooltip').textContent = this.formatTime(this.segmentStart);
                document.getElementById('endTooltip').textContent = this.formatTime(this.segmentStart + this.segmentDuration);
                document.getElementById('selectionTooltip').textContent = 
                    `${this.formatTime(this.segmentStart)} - ${this.formatTime(this.segmentStart + this.segmentDuration)}`;
                
                // Update time displays
                document.getElementById('startTime').textContent = this.formatTime(this.segmentStart);
                document.getElementById('durationTime').textContent = this.formatTime(this.segmentDuration);
                document.getElementById('endTime').textContent = this.formatTime(this.segmentStart + this.segmentDuration);
                document.getElementById('segmentLength').textContent = this.formatTime(this.segmentDuration);
                
                // Update stats
                document.getElementById('statSegment').textContent = 
                    `${this.segmentStart.toFixed(2)}s - ${(this.segmentStart + this.segmentDuration).toFixed(2)}s`;
                
                // Update preview video smoothly
                const previewVideo = document.getElementById('previewVideo');
                if (previewVideo.src && !previewVideo.seeking) {
                    // Only update if not already seeking
                    const targetTime = this.segmentStart;
                    if (Math.abs(previewVideo.currentTime - targetTime) > 0.1) {
                        previewVideo.currentTime = targetTime;
                    }
                }
                
                // Update preview time display
                document.getElementById('previewTimeDisplay').textContent = 
                    `0:00 / ${this.formatTime(this.segmentDuration)}`;
                
                // Update quick select buttons
                document.querySelectorAll('.time-btn').forEach(btn => {
                    btn.classList.remove('active');
                    const btnDuration = parseFloat(btn.dataset.duration);
                    if (Math.abs(this.segmentDuration - btnDuration) < 0.05) {
                        btn.classList.add('active');
                    }
                });
                
                this.updateEstimatedFrames();
            }

            generateTimelineRuler() {
                const ruler = document.getElementById('timelineRuler');
                ruler.innerHTML = '';
                
                if (!this.video) return;
                
                const duration = this.video.duration;
                const marks = Math.min(10, Math.floor(duration));
                
                for (let i = 0; i <= marks; i++) {
                    const time = (duration / marks) * i;
                    const mark = document.createElement('div');
                    mark.className = 'timeline-ruler-mark';
                    mark.setAttribute('data-time', this.formatTime(time));
                    mark.style.left = (i / marks) * 100 + '%';
                    ruler.appendChild(mark);
                }
            }

            generateWaveform() {
                const canvas = document.getElementById('waveformCanvas');
                const ctx = canvas.getContext('2d');
                const slider = document.getElementById('timelineSlider');
                
                // Set canvas size
                canvas.width = slider.offsetWidth;
                canvas.height = slider.offsetHeight;
                
                // Generate fake waveform data
                const bars = 100;
                const barWidth = canvas.width / bars;
                
                ctx.fillStyle = '#667eea';
                
                for (let i = 0; i < bars; i++) {
                    const height = Math.random() * 0.7 + 0.3; // 30% to 100% height
                    const barHeight = canvas.height * height;
                    const x = i * barWidth;
                    const y = (canvas.height - barHeight) / 2;
                    
                    ctx.fillRect(x, y, barWidth - 1, barHeight);
                }
            }

            updateEstimatedFrames() {
                const fps = parseInt(document.getElementById('fps').value);
                const estimatedFrames = Math.floor(this.segmentDuration * fps);
                document.getElementById('statFrames').textContent = estimatedFrames + ' 帧';
                
                const fpsInfo = document.getElementById('fpsInfo');
                fpsInfo.textContent = `帧/秒 (建议5-30帧/秒) - 预计提取 ${estimatedFrames} 帧`;
            }

            async extractFrames() {
                const fps = parseInt(document.getElementById('fps').value);
                const frameCount = Math.floor(this.segmentDuration * fps);
                
                // Show loading state
                const extractBtn = document.getElementById('extractBtn');
                extractBtn.innerHTML = '<span class="loading"></span> <span>正在提取...</span>';
                extractBtn.disabled = true;
                
                // Show progress
                this.showProgress('正在提取视频帧', '准备提取...');
                
                // Create canvas for frame extraction
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                canvas.width = this.video.videoWidth;
                canvas.height = this.video.videoHeight;
                
                this.frames = [];
                
                for (let i = 0; i < frameCount; i++) {
                    const time = this.segmentStart + (i / fps);
                    await this.seekToTime(time);
                    
                    ctx.drawImage(this.video, 0, 0);
                    
                    const blob = await new Promise(resolve => {
                        canvas.toBlob(resolve, 'image/jpeg', 0.9);
                    });
                    
                    this.frames.push({
                        index: i,
                        time: time,
                        blob: blob,
                        url: URL.createObjectURL(blob)
                    });
                    
                    // Update progress
                    const progress = ((i + 1) / frameCount) * 100;
                    this.updateProgress(progress, `正在提取第 ${i + 1}/${frameCount} 帧`);
                }
                
                // Reset button
                extractBtn.innerHTML = '<span>🎬</span> <span>开始提取帧</span>';
                extractBtn.disabled = false;
                
                // Hide progress
                this.hideProgress();
                
                // Show frame selection page
                this.showFrameSelection();
            }

            seekToTime(time) {
                return new Promise(resolve => {
                    this.video.currentTime = time;
                    this.video.onseeked = resolve;
                });
            }

            showFrameSelection() {
                document.getElementById('uploadPage').style.display = 'none';
                document.getElementById('framePage').style.display = 'block';
                this.currentPage = 'frame';
                
                // Initialize all frames as selected
                this.frames.forEach((frame, index) => {
                    this.selectedFrames.add(index);
                });
                
                this.renderFrames();
                this.updateFramePreview(0);
                
                // Update frame slider max value
                document.getElementById('frameSlider').max = this.frames.length;
                document.getElementById('totalFrameCount').textContent = this.frames.length;
                document.getElementById('frameTotal').textContent = this.frames.length;
                document.getElementById('lastFrameLabel').textContent = this.frames.length;
            }

            renderFrames() {
                const grid = document.getElementById('framesGrid');
                grid.innerHTML = '';
                
                this.frames.forEach((frame, index) => {
                    const frameDiv = document.createElement('div');
                    frameDiv.className = 'frame-item';
                    if (this.selectedFrames.has(index)) {
                        frameDiv.classList.add('selected');
                    }
                    
                    frameDiv.innerHTML = `
                        <input type="checkbox" class="frame-checkbox" ${this.selectedFrames.has(index) ? 'checked' : ''}>
                        <img src="${frame.url}" class="frame-image" alt="Frame ${index + 1}">
                        <div class="frame-label">帧 ${index + 1}</div>
                    `;
                    
                    frameDiv.addEventListener('click', (e) => {
                        if (!e.target.classList.contains('frame-checkbox')) {
                            this.handleFrameClick(index, e);
                        }
                    });
                    
                    const checkbox = frameDiv.querySelector('.frame-checkbox');
                    checkbox.addEventListener('change', () => {
                        this.toggleFrame(index);
                    });
                    
                    grid.appendChild(frameDiv);
                });
                
                this.updateSelectedCount();
            }

            handleFrameClick(index, event) {
                if (this.shiftKeyPressed && this.lastClickedFrame !== null) {
                    // Batch selection
                    const start = Math.min(this.lastClickedFrame, index);
                    const end = Math.max(this.lastClickedFrame, index);
                    
                    const shouldSelect = !this.selectedFrames.has(index);
                    
                    for (let i = start; i <= end; i++) {
                        if (shouldSelect) {
                            this.selectedFrames.add(i);
                        } else {
                            this.selectedFrames.delete(i);
                        }
                    }
                    
                    this.renderFrames();
                } else {
                    this.toggleFrame(index);
                }
                
                this.lastClickedFrame = index;
            }

            toggleFrame(index) {
                if (this.selectedFrames.has(index)) {
                    this.selectedFrames.delete(index);
                } else {
                    this.selectedFrames.add(index);
                }
                
                const frameItem = document.querySelectorAll('.frame-item')[index];
                frameItem.classList.toggle('selected');
                frameItem.querySelector('.frame-checkbox').checked = this.selectedFrames.has(index);
                
                this.updateSelectedCount();
            }

            selectAllFrames() {
                this.frames.forEach((_, index) => {
                    this.selectedFrames.add(index);
                });
                this.renderFrames();
            }

            deselectAllFrames() {
                this.selectedFrames.clear();
                this.renderFrames();
            }

            updateSelectedCount() {
                const count = this.selectedFrames.size;
                document.getElementById('selectedCount').textContent = count;
                document.getElementById('downloadFramesBtn').textContent = `打包下载原图 (${count})`;
                document.getElementById('startChromaBtn').innerHTML = `<span>✨</span> <span>开始抠图(${count})</span>`;
            }

            updateFramePreview(index) {
                const frame = this.frames[index];
                if (frame) {
                    document.getElementById('previewFrameImg').src = frame.url;
                    document.querySelector('.frame-number').textContent = `${index + 1} / ${this.frames.length}`;
                    document.getElementById('currentFrameLabel').textContent = `第 ${index + 1} 帧`;
                    document.getElementById('frameSlider').value = index + 1;
                }
            }

            async downloadSelectedFrames() {
                if (this.selectedFrames.size === 0) {
                    alert('请至少选择一帧');
                    return;
                }
                
                const zip = new JSZip();
                const folder = zip.folder('frames');
                
                for (const index of this.selectedFrames) {
                    const frame = this.frames[index];
                    const filename = `frame_${String(index + 1).padStart(4, '0')}.jpg`;
                    folder.file(filename, frame.blob);
                }
                
                const blob = await zip.generateAsync({
                    type: 'blob',
                    compression: 'DEFLATE',
                    compressionOptions: { level: 6 }
                });
                
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `frames_${Date.now()}.zip`;
                a.click();
                
                setTimeout(() => URL.revokeObjectURL(url), 1000);
            }

            async previewChromaKey() {
                const currentIndex = parseInt(document.getElementById('frameSlider').value) - 1;
                const frame = this.frames[currentIndex];
                
                if (!frame) return;
                
                // Process the current frame
                const processedCanvas = await this.processFrame(frame);
                
                // Create or update preview overlay
                let previewOverlay = document.getElementById('chromaPreviewOverlay');
                if (!previewOverlay) {
                    previewOverlay = document.createElement('div');
                    previewOverlay.id = 'chromaPreviewOverlay';
                    previewOverlay.style.cssText = `
                        position: fixed;
                        top: 0;
                        left: 0;
                        right: 0;
                        bottom: 0;
                        background: rgba(0, 0, 0, 0.8);
                        display: flex;
                        justify-content: center;
                        align-items: center;
                        z-index: 1000;
                        cursor: pointer;
                    `;
                    
                    const previewContainer = document.createElement('div');
                    previewContainer.style.cssText = `
                        background: white;
                        border-radius: 20px;
                        padding: 30px;
                        max-width: 90%;
                        max-height: 90%;
                        overflow: auto;
                        box-shadow: 0 20px 50px rgba(0, 0, 0, 0.3);
                        cursor: default;
                    `;
                    
                    const title = document.createElement('h3');
                    title.textContent = '抠图效果预览';
                    title.style.cssText = 'margin-bottom: 20px; text-align: center;';
                    
                    const canvasContainer = document.createElement('div');
                    canvasContainer.style.cssText = `
                        display: flex;
                        gap: 20px;
                        justify-content: center;
                        align-items: center;
                        flex-wrap: wrap;
                    `;
                    
                    const originalDiv = document.createElement('div');
                    originalDiv.style.cssText = 'text-align: center;';
                    const originalLabel = document.createElement('p');
                    originalLabel.textContent = '原图';
                    originalLabel.style.cssText = 'margin-bottom: 10px; font-weight: bold;';
                    const originalCanvas = document.createElement('canvas');
                    originalCanvas.style.cssText = 'max-width: 400px; max-height: 300px; border: 1px solid #ddd;';
                    const originalCtx = originalCanvas.getContext('2d');
                    const originalImg = new Image();
                    originalImg.src = frame.url;
                    originalImg.onload = () => {
                        originalCanvas.width = originalImg.width;
                        originalCanvas.height = originalImg.height;
                        originalCtx.drawImage(originalImg, 0, 0);
                    };
                    originalDiv.appendChild(originalLabel);
                    originalDiv.appendChild(originalCanvas);
                    
                    const processedDiv = document.createElement('div');
                    processedDiv.style.cssText = 'text-align: center;';
                    const processedLabel = document.createElement('p');
                    processedLabel.textContent = '抠图效果（棋盘格表示透明）';
                    processedLabel.style.cssText = 'margin-bottom: 10px; font-weight: bold;';
                    
                    // Display with checkerboard background
                    const displayCanvas = document.createElement('canvas');
                    displayCanvas.width = processedCanvas.width;
                    displayCanvas.height = processedCanvas.height;
                    displayCanvas.style.cssText = 'max-width: 400px; max-height: 300px; border: 1px solid #ddd; object-fit: contain;';
                    const displayCtx = displayCanvas.getContext('2d');
                    
                    // Draw checkerboard
                    const checkerSize = 10;
                    displayCtx.fillStyle = '#ffffff';
                    displayCtx.fillRect(0, 0, displayCanvas.width, displayCanvas.height);
                    displayCtx.fillStyle = '#e0e0e0';
                    for (let y = 0; y < displayCanvas.height; y += checkerSize) {
                        for (let x = 0; x < displayCanvas.width; x += checkerSize) {
                            if ((x / checkerSize + y / checkerSize) % 2 === 0) {
                                displayCtx.fillRect(x, y, checkerSize, checkerSize);
                            }
                        }
                    }
                    
                    // Draw processed image
                    displayCtx.drawImage(processedCanvas, 0, 0);
                    
                    processedDiv.appendChild(processedLabel);
                    processedDiv.appendChild(displayCanvas);
                    
                    canvasContainer.appendChild(originalDiv);
                    canvasContainer.appendChild(processedDiv);
                    
                    const closeBtn = document.createElement('button');
                    closeBtn.textContent = '关闭预览';
                    closeBtn.style.cssText = `
                        margin-top: 20px;
                        padding: 10px 30px;
                        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                        color: white;
                        border: none;
                        border-radius: 50px;
                        cursor: pointer;
                        font-size: 16px;
                        display: block;
                        margin-left: auto;
                        margin-right: auto;
                    `;
                    
                    previewContainer.appendChild(title);
                    previewContainer.appendChild(canvasContainer);
                    previewContainer.appendChild(closeBtn);
                    
                    previewOverlay.appendChild(previewContainer);
                    document.body.appendChild(previewOverlay);
                    
                    // Close handlers
                    const closeOverlay = () => {
                        previewOverlay.remove();
                    };
                    
                    closeBtn.addEventListener('click', closeOverlay);
                    previewOverlay.addEventListener('click', (e) => {
                        if (e.target === previewOverlay) {
                            closeOverlay();
                        }
                    });
                    
                    previewContainer.addEventListener('click', (e) => {
                        e.stopPropagation();
                    });
                } else {
                    previewOverlay.style.display = 'flex';
                }
            }

            async startChromaKey() {
                if (this.selectedFrames.size === 0) {
                    alert('请至少选择一帧');
                    return;
                }
                
                // Test with first frame to show detected background color
                const firstSelectedIndex = Array.from(this.selectedFrames)[0];
                const testFrame = this.frames[firstSelectedIndex];
                const testImg = new Image();
                testImg.src = testFrame.url;
                await new Promise(resolve => testImg.onload = resolve);
                
                const testCanvas = document.createElement('canvas');
                const testCtx = testCanvas.getContext('2d');
                testCanvas.width = testImg.width;
                testCanvas.height = testImg.height;
                testCtx.drawImage(testImg, 0, 0);
                
                const testImageData = testCtx.getImageData(0, 0, testCanvas.width, testCanvas.height);
                const bgColor = this.detectBackgroundColor(testImageData);
                
                // Update UI to show detected background color
                const colorDisplay = document.getElementById('detectedBgColor');
                const rgbDisplay = document.getElementById('bgColorRGB');
                if (colorDisplay && rgbDisplay) {
                    colorDisplay.style.backgroundColor = `rgb(${bgColor.r}, ${bgColor.g}, ${bgColor.b})`;
                    rgbDisplay.textContent = `RGB(${bgColor.r}, ${bgColor.g}, ${bgColor.b})`;
                }
                
                this.showProgress('正在进行抠图处理', '准备处理...');
                
                this.processedFrames = [];
                const selectedIndices = Array.from(this.selectedFrames).sort((a, b) => a - b);
                
                for (let i = 0; i < selectedIndices.length; i++) {
                    const index = selectedIndices[i];
                    const frame = this.frames[index];
                    
                    const progress = ((i + 1) / selectedIndices.length) * 100;
                    this.updateProgress(progress, `正在处理第 ${i + 1}/${selectedIndices.length} 帧`);
                    
                    const processedCanvas = await this.processFrame(frame);
                    this.processedFrames.push({
                        canvas: processedCanvas,
                        index: index
                    });
                }
                
                this.hideProgress();
                
                // Show processed frames
                this.showProcessedFrames();
            }

            async processFrame(frame) {
                const img = new Image();
                img.src = frame.url;
                await new Promise(resolve => img.onload = resolve);
                
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                canvas.width = img.width;
                canvas.height = img.height;
                
                ctx.drawImage(img, 0, 0);
                
                if (this.settings.method === 'chroma') {
                    return this.chromaKeyProcess(canvas, ctx);
                } else {
                    // AI method would go here - for now, just return the original
                    return canvas;
                }
            }

            chromaKeyProcess(canvas, ctx) {
                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                const data = imageData.data;
                const width = canvas.width;
                const height = canvas.height;

                // Auto-detect background color from edges
                const bgColor = this.detectBackgroundColor(imageData);
                console.log('检测到背景颜色:', bgColor);

                const tolerance = this.settings.tolerance * 255;

                // Check if background is white-ish
                const isWhiteBackground = bgColor.r > 200 && bgColor.g > 200 && bgColor.b > 200;

                // 第一步：基础色键处理
                const removeMap = new Uint8Array(width * height);
                this.basicChromaKey(data, removeMap, bgColor, tolerance, isWhiteBackground, width, height);



                // 第三步：应用移除效果
                this.applyRemoval(data, removeMap, bgColor, tolerance, width, height);

                // Apply edge smoothing if enabled
                if (this.settings.smoothEdges) {
                    this.smoothAlphaChannel(imageData);
                }

                // Remove watermarks if enabled
                if (this.settings.removeWatermark) {
                    this.removeWatermarks(imageData);
                }

                ctx.putImageData(imageData, 0, 0);

                // Auto-crop transparent edges if enabled
                if (this.settings.autoCrop) {
                    const cropped = this.autoCropCanvas(canvas);
                    return cropped;
                }

                return canvas;
            }

            // 基础色键处理
            basicChromaKey(data, removeMap, bgColor, tolerance, isWhiteBackground, width, height) {
                for (let i = 0, pixelIndex = 0; i < data.length; i += 4, pixelIndex++) {
                    const r = data[i];
                    const g = data[i + 1];
                    const b = data[i + 2];
                    const a = data[i + 3];

                    // Skip already transparent pixels
                    if (a === 0) {
                        removeMap[pixelIndex] = 1;
                        continue;
                    }

                    // Calculate color distance
                    const distance = Math.sqrt(
                        Math.pow(r - bgColor.r, 2) +
                        Math.pow(g - bgColor.g, 2) +
                        Math.pow(b - bgColor.b, 2)
                    );

                    let shouldRemove = false;

                    if (isWhiteBackground) {
                        const brightness = (r + g + b) / 3;
                        const colorVariance = Math.max(r, g, b) - Math.min(r, g, b);

                        // 基础白色检测
                        if (r > 245 && g > 245 && b > 245) {
                            shouldRemove = true;
                        }
                        // 颜色距离检测
                        else if (distance < tolerance) {
                            shouldRemove = true;
                        }
                        // 灰白色检测
                        else if (brightness > 230 && colorVariance < 20) {
                            shouldRemove = true;
                        }
                    } else {
                        shouldRemove = distance < tolerance;
                    }

                    removeMap[pixelIndex] = shouldRemove ? 1 : 0;
                }
            }



            // 应用移除效果
            applyRemoval(data, removeMap, bgColor, tolerance, width, height) {
                for (let i = 0, pixelIndex = 0; i < data.length; i += 4, pixelIndex++) {
                    if (removeMap[pixelIndex]) {
                        const r = data[i];
                        const g = data[i + 1];
                        const b = data[i + 2];

                        // 计算颜色距离用于边缘软化
                        const distance = Math.sqrt(
                            Math.pow(r - bgColor.r, 2) +
                            Math.pow(g - bgColor.g, 2) +
                            Math.pow(b - bgColor.b, 2)
                        );

                        // 应用透明度，带软边缘
                        const edge = tolerance * 0.4;
                        if (distance < tolerance - edge) {
                            data[i + 3] = 0; // 完全透明
                        } else {
                            // 渐变过渡
                            const ratio = (distance - (tolerance - edge)) / edge;
                            data[i + 3] = Math.round(255 * Math.pow(ratio, 1.5));
                        }

                        // 颜色校正边缘像素
                        if (data[i + 3] > 0 && data[i + 3] < 255) {
                            const alpha = data[i + 3] / 255;

                            // 去除背景色污染
                            const despillFactor = (1 - alpha) * 0.4;
                            data[i] = Math.max(0, Math.min(255, data[i] - bgColor.r * despillFactor));
                            data[i + 1] = Math.max(0, Math.min(255, data[i + 1] - bgColor.g * despillFactor));
                            data[i + 2] = Math.max(0, Math.min(255, data[i + 2] - bgColor.b * despillFactor));
                        }
                    }
                }
            }

            autoCropCanvas(sourceCanvas) {
                const ctx = sourceCanvas.getContext('2d');
                const imageData = ctx.getImageData(0, 0, sourceCanvas.width, sourceCanvas.height);
                const data = imageData.data;
                const width = sourceCanvas.width;
                const height = sourceCanvas.height;
                
                // Find bounds of non-transparent pixels
                let minX = width;
                let minY = height;
                let maxX = 0;
                let maxY = 0;
                
                // Scan for non-transparent pixels
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const alpha = data[(y * width + x) * 4 + 3];
                        if (alpha > 10) { // Threshold for considering a pixel non-transparent
                            minX = Math.min(minX, x);
                            minY = Math.min(minY, y);
                            maxX = Math.max(maxX, x);
                            maxY = Math.max(maxY, y);
                        }
                    }
                }
                
                // Add small padding
                const padding = 5;
                minX = Math.max(0, minX - padding);
                minY = Math.max(0, minY - padding);
                maxX = Math.min(width - 1, maxX + padding);
                maxY = Math.min(height - 1, maxY + padding);
                
                // Calculate new dimensions
                const newWidth = maxX - minX + 1;
                const newHeight = maxY - minY + 1;
                
                // Create new canvas with cropped dimensions
                const croppedCanvas = document.createElement('canvas');
                croppedCanvas.width = newWidth;
                croppedCanvas.height = newHeight;
                const croppedCtx = croppedCanvas.getContext('2d');
                
                // Draw cropped image
                croppedCtx.drawImage(sourceCanvas, minX, minY, newWidth, newHeight, 0, 0, newWidth, newHeight);
                
                return croppedCanvas;
            }

            smoothAlphaChannel(imageData) {
                const data = imageData.data;
                const width = imageData.width;
                const height = imageData.height;
                const alpha = new Uint8Array(width * height);
                const smoothedAlpha = new Uint8Array(width * height);
                
                // Extract alpha channel
                for (let i = 0, j = 0; i < data.length; i += 4, j++) {
                    alpha[j] = data[i + 3];
                }
                
                // Apply multiple passes of smoothing for better results
                const passes = 2;
                let source = alpha;
                let target = smoothedAlpha;
                
                for (let pass = 0; pass < passes; pass++) {
                    // Smooth alpha channel with gaussian-like kernel
                    for (let y = 1; y < height - 1; y++) {
                        for (let x = 1; x < width - 1; x++) {
                            const idx = y * width + x;
                            const current = source[idx];
                            
                            // Only process edge pixels
                            if (current > 5 && current < 250) {
                                let sum = 0;
                                let weightSum = 0;
                                
                                // 3x3 gaussian-like kernel
                                const kernel = [
                                    [1, 2, 1],
                                    [2, 4, 2],
                                    [1, 2, 1]
                                ];
                                
                                for (let dy = -1; dy <= 1; dy++) {
                                    for (let dx = -1; dx <= 1; dx++) {
                                        const nidx = (y + dy) * width + (x + dx);
                                        const weight = kernel[dy + 1][dx + 1];
                                        sum += source[nidx] * weight;
                                        weightSum += weight;
                                    }
                                }
                                
                                target[idx] = Math.round(sum / weightSum);
                            } else {
                                target[idx] = current;
                            }
                        }
                    }
                    
                    // Swap buffers for next pass
                    const temp = source;
                    source = target;
                    target = temp;
                }
                
                // Apply final smoothed alpha back to image
                for (let i = 0, j = 0; i < data.length; i += 4, j++) {
                    data[i + 3] = source[j];
                }
            }

            detectBackgroundColor(imageData) {
                const data = imageData.data;
                const width = imageData.width;
                const height = imageData.height;
                
                const colors = [];
                const edgeWidth = Math.min(50, Math.floor(width * 0.1)); // Sample from 10% of edge or 50px
                const edgeHeight = Math.min(50, Math.floor(height * 0.1));
                
                // Sample more comprehensively from corners and edges
                // Top-left corner
                for (let y = 0; y < edgeHeight; y += 2) {
                    for (let x = 0; x < edgeWidth; x += 2) {
                        const i = (y * width + x) * 4;
                        if (data[i + 3] > 250) { // Only consider mostly opaque pixels
                            colors.push({ r: data[i], g: data[i + 1], b: data[i + 2] });
                        }
                    }
                }
                
                // Top-right corner
                for (let y = 0; y < edgeHeight; y += 2) {
                    for (let x = width - edgeWidth; x < width; x += 2) {
                        const i = (y * width + x) * 4;
                        if (data[i + 3] > 250) {
                            colors.push({ r: data[i], g: data[i + 1], b: data[i + 2] });
                        }
                    }
                }
                
                // Bottom-left corner
                for (let y = height - edgeHeight; y < height; y += 2) {
                    for (let x = 0; x < edgeWidth; x += 2) {
                        const i = (y * width + x) * 4;
                        if (data[i + 3] > 250) {
                            colors.push({ r: data[i], g: data[i + 1], b: data[i + 2] });
                        }
                    }
                }
                
                // Bottom-right corner
                for (let y = height - edgeHeight; y < height; y += 2) {
                    for (let x = width - edgeWidth; x < width; x += 2) {
                        const i = (y * width + x) * 4;
                        if (data[i + 3] > 250) {
                            colors.push({ r: data[i], g: data[i + 1], b: data[i + 2] });
                        }
                    }
                }
                
                // Use k-means clustering to find the dominant background color
                // Simplified k-means with k=1
                if (colors.length === 0) {
                    return { r: 255, g: 255, b: 255 }; // Default to white if no colors found
                }
                
                // Calculate average color
                let avgR = 0, avgG = 0, avgB = 0;
                colors.forEach(color => {
                    avgR += color.r;
                    avgG += color.g;
                    avgB += color.b;
                });
                
                avgR = Math.round(avgR / colors.length);
                avgG = Math.round(avgG / colors.length);
                avgB = Math.round(avgB / colors.length);
                
                // Refine by finding colors close to average
                const threshold = 30;
                const refinedColors = colors.filter(color => {
                    const dist = Math.sqrt(
                        Math.pow(color.r - avgR, 2) +
                        Math.pow(color.g - avgG, 2) +
                        Math.pow(color.b - avgB, 2)
                    );
                    return dist < threshold;
                });
                
                if (refinedColors.length > 0) {
                    avgR = 0; avgG = 0; avgB = 0;
                    refinedColors.forEach(color => {
                        avgR += color.r;
                        avgG += color.g;
                        avgB += color.b;
                    });
                    avgR = Math.round(avgR / refinedColors.length);
                    avgG = Math.round(avgG / refinedColors.length);
                    avgB = Math.round(avgB / refinedColors.length);
                }
                
                return { r: avgR, g: avgG, b: avgB };
            }

            removeWatermarks(imageData) {
                const width = imageData.width;
                const height = imageData.height;
                const size = this.settings.watermarkSize / 100;
                
                const regions = [];
                
                if (this.settings.watermarkCorners.TL) {
                    regions.push({ x: 0, y: 0, w: width * size, h: height * size });
                }
                if (this.settings.watermarkCorners.TR) {
                    regions.push({ x: width * (1 - size), y: 0, w: width * size, h: height * size });
                }
                if (this.settings.watermarkCorners.BL) {
                    regions.push({ x: 0, y: height * (1 - size), w: width * size, h: height * size });
                }
                if (this.settings.watermarkCorners.BR) {
                    regions.push({ x: width * (1 - size), y: height * (1 - size), w: width * size, h: height * size });
                }
                
                // Simple watermark removal - make corners transparent
                regions.forEach(region => {
                    for (let y = region.y; y < region.y + region.h; y++) {
                        for (let x = region.x; x < region.x + region.w; x++) {
                            const i = (Math.floor(y) * width + Math.floor(x)) * 4;
                            if (i < imageData.data.length) {
                                // Gradually fade out towards corner
                                const distanceFromCorner = Math.min(
                                    Math.min(x - region.x, region.x + region.w - x),
                                    Math.min(y - region.y, region.y + region.h - y)
                                );
                                const fadeRatio = Math.max(0, 1 - (distanceFromCorner / (region.w * 0.3)));
                                
                                imageData.data[i + 3] *= (1 - fadeRatio);
                            }
                        }
                    }
                });
            }

            showProcessedFrames() {
                // Show result section
                document.getElementById('resultSection').style.display = 'block';
                
                // Clear previous results
                const grid = document.getElementById('processedFramesGrid');
                grid.innerHTML = '';
                
                // Display all processed frames
                this.processedFrames.forEach((item, idx) => {
                    const frameDiv = document.createElement('div');
                    frameDiv.className = 'processed-frame-item';
                    
                    const img = document.createElement('img');
                    img.className = 'processed-frame-img';
                    img.src = item.canvas.toDataURL('image/png');
                    img.alt = `处理后的帧 ${item.index + 1}`;
                    
                    frameDiv.appendChild(img);
                    grid.appendChild(frameDiv);
                });
                
                // Scroll to result
                document.getElementById('resultSection').scrollIntoView({ behavior: 'smooth' });
            }

            async downloadResult() {
                if (this.processedFrames.length === 0) {
                    alert('没有处理后的图片可下载');
                    return;
                }
                
                const zip = new JSZip();
                const folder = zip.folder('processed_frames');
                
                // Convert each processed canvas to PNG blob and add to zip
                for (let i = 0; i < this.processedFrames.length; i++) {
                    const item = this.processedFrames[i];
                    const canvas = item.canvas;
                    
                    const blob = await new Promise(resolve => {
                        canvas.toBlob(resolve, 'image/png');
                    });
                    
                    const filename = `frame_${String(item.index + 1).padStart(4, '0')}_transparent.png`;
                    folder.file(filename, blob);
                }
                
                // Generate and download zip
                const zipBlob = await zip.generateAsync({
                    type: 'blob',
                    compression: 'DEFLATE',
                    compressionOptions: { level: 6 }
                });
                
                const url = URL.createObjectURL(zipBlob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `processed_frames_${Date.now()}.zip`;
                a.click();
                
                setTimeout(() => URL.revokeObjectURL(url), 1000);
            }

            showProgress(title, text) {
                document.getElementById('progressTitle').textContent = title;
                document.getElementById('progressText').textContent = text;
                document.getElementById('progressBar').style.width = '0%';
                document.getElementById('progressOverlay').style.display = 'flex';
            }

            updateProgress(percentage, text) {
                document.getElementById('progressBar').style.width = percentage + '%';
                document.getElementById('progressText').textContent = text;
            }

            hideProgress() {
                document.getElementById('progressOverlay').style.display = 'none';
            }
        }

        // Initialize the application when DOM is ready
        document.addEventListener('DOMContentLoaded', () => {
            new VideoToFrames();
        });
    </script>
</body>
</html>